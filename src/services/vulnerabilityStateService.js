const Vulnerability = require('../models/vulnerability');

class VulnerabilityStateService {
  // Define valid state transitions
  #stateTransitions = {
    'Open': ['In Progress'],
    'In Progress': ['Fixed', "Won't Fix", 'Open', 'False Positive'],
    'Fixed': ['Closed', 'Open'],
    'False Positive': ['Closed', 'Open'],
    "Won't Fix": ['Closed', 'Open'],
    'Closed': ['Open', 'Resurfaced'],
    'Resurfaced': ['In Progress', 'Open'],
  };

  // Validate state transition
  #validateStateTransition(currentState, newState) {
    const validTransitions = this.#stateTransitions[currentState];
    if (!validTransitions) {
      throw new Error(`Invalid current state: ${currentState}`);
    }
    if (!validTransitions.includes(newState)) {
      throw new Error(`Invalid state transition from ${currentState} to ${newState}. Valid transitions are: ${validTransitions.join(', ')}`);
    }
  }

  async changeState(id, newState) {
    try {
      const vulnerability = await Vulnerability.findByPk(id);
      
      if (!vulnerability) {
        throw new Error('Vulnerability not found');
      }

      // Validate the state transition
      this.#validateStateTransition(vulnerability.status, newState);

      const updateData = {
        status: newState,
        lastUpdatedDate: new Date(),
      };

      // Add any automatic date updates based on state
      if (newState === 'Fixed' || newState === 'Closed') {
        updateData.resolutionDate = new Date();
      }

      await vulnerability.update(updateData);
      return vulnerability;
    } catch (error) {
      throw new Error(`Error changing vulnerability state: ${error.message}`);
    }
  }
}

module.exports = new VulnerabilityStateService(); 