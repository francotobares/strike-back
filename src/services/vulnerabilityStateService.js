const Vulnerability = require('../models/vulnerability');

class VulnerabilityStateService {
  constructor() {
    this.validStates = ['Open', 'In Progress', 'Fixed', 'Closed', "Won't Fix", "Resurfaced"];
    this.validTransitions = {
      'Open': ['In Progress', 'Closed', "Won't Fix"],
      'In Progress': ['Fixed', 'Closed', "Won't Fix", 'Open'],
      'Fixed': ['Closed', 'In Progress'],
      'Closed': ['Resurfaced'],
      "Won't Fix": ['Resurfaced'],
      'Resurfaced': ['Open','In Progress', 'Fixed']
    };
  }

  async changeState(vulnerability, newState) {
    if (!this.validStates.includes(newState)) {
      throw new Error('Invalid state');
    }

    if (!this.isValidTransition(vulnerability.state, newState)) {
      throw new Error(`Invalid state transition from ${vulnerability.state} to ${newState}`);
    }

    vulnerability.state = newState;
    vulnerability.lastUpdatedDate = new Date();
    
    if (newState === 'Fixed') {
      vulnerability.resolutionDate = new Date();
    }

    await vulnerability.save();
    return vulnerability;
  }

  isValidTransition(currentState, newState) {
    return this.validTransitions[currentState]?.includes(newState) || false;
  }

  /**
   * Gets the current state and possible next states
   * @param {string} currentState - The current state of the vulnerability
   * @returns {Object} Object containing current state and possible next states
   */
  getStateWithTransitions(currentState) {
    return {
      currentState,
      possibleNextStates: this.validTransitions[currentState] || []
    };
  }
}

module.exports = VulnerabilityStateService; 