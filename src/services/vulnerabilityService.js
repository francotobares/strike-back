const Vulnerability = require('../models/vulnerability');
const VulnerabilityStateService = require('./vulnerabilityStateService');

class VulnerabilityService {
  constructor() {
    this.stateService = new VulnerabilityStateService();
  }

  // Get all vulnerabilities
  async getAllVulnerabilities(includeDeleted = false) {
    try {
      let vulnerabilities;
      if (includeDeleted) {
        vulnerabilities = await Vulnerability.scope('withDeleted').findAll();
      } else {
        vulnerabilities = await Vulnerability.findAll({
          where: {
            deleted: false
          }
        });
      }

      return vulnerabilities.map(vulnerability => {
        const completeState = this.stateService.getStateWithTransitions(vulnerability.state);
        return {
          ...vulnerability.toJSON(),
          completeState
        };
      });
    } catch (error) {
      throw new Error(`Error fetching vulnerabilities: ${error.message}`);
    }
  }

  // Get vulnerability by ID
  async getVulnerabilityById(id, includeDeleted = false) {
    try {
      const vulnerability = includeDeleted
        ? await Vulnerability.scope('withDeleted').findByPk(id)
        : await Vulnerability.findByPk(id);

      if (!vulnerability) {
        throw new Error('Vulnerability not found');
      }
      return vulnerability;
    } catch (error) {
      throw new Error(`Error fetching vulnerability: ${error.message}`);
    }
  }

  // Create new vulnerability
  async createVulnerability(vulnerabilityData) {
    try {
      return await Vulnerability.create(vulnerabilityData);
    } catch (error) {
      throw new Error(`Error creating vulnerability: ${error.message}`);
    }
  }

  // Update vulnerability
  async updateVulnerability(id, updateData) {
    try {
      const vulnerability = await this.getVulnerabilityById(id);
      
      // Update lastUpdatedDate
      updateData.lastUpdatedDate = new Date();
      
      await vulnerability.update(updateData);
      return vulnerability;
    } catch (error) {
      throw new Error(`Error updating vulnerability: ${error.message}`);
    }
  }

  // Update vulnerability state
  async updateState(id, newState) {
    try {
      const vulnerability = await this.getVulnerabilityById(id);
      return await this.stateService.changeState(vulnerability, newState);
    } catch (error) {
      throw error;
    }
  }

  // Delete vulnerability
  async deleteVulnerability(id) {
    try {
      const vulnerability = await this.getVulnerabilityById(id);
      
      await vulnerability.update({
        deleted: true,
        deletedAt: new Date(),
        lastUpdatedDate: new Date()
      });

      return { 
        message: 'Vulnerability deleted successfully',
        id: vulnerability.id 
      };
    } catch (error) {
      throw new Error(`Error deleting vulnerability: ${error.message}`);
    }
  }

  // Add method to restore deleted vulnerability
  async restoreVulnerability(id) {
    try {
      const vulnerability = await this.getVulnerabilityById(id, true);
      
      if (!vulnerability.deleted) {
        throw new Error('Vulnerability is not deleted');
      }

      await vulnerability.update({
        deleted: false,
        deletedAt: null,
        lastUpdatedDate: new Date()
      });

      return {
        message: 'Vulnerability restored successfully',
        vulnerability
      };
    } catch (error) {
      throw new Error(`Error restoring vulnerability: ${error.message}`);
    }
  }

  // Add method to get deleted vulnerabilities
  async getDeletedVulnerabilities() {
    try {
      return await Vulnerability.scope('withDeleted').findAll({
        where: {
          deleted: true
        }
      });
    } catch (error) {
      throw new Error(`Error fetching deleted vulnerabilities: ${error.message}`);
    }
  }
}

module.exports = new VulnerabilityService(); 