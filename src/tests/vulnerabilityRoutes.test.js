const request = require('supertest');
const app = require('../app');
const { sequelize } = require('../db/connection');

// First, mock the services
jest.mock('../services/vulnerabilityService');
jest.mock('../services/vulnerabilityStateService');

// Then import them
const vulnerabilityService = require('../services/vulnerabilityService');
const VulnerabilityStateService = require('../services/vulnerabilityStateService');

describe('Vulnerability Routes', () => {
  let mockStateService;

  beforeAll(async () => {
    sequelize.options.logging = false;
    await sequelize.sync({ force: true });

    // Setup mock state service
    mockStateService = {
      changeState: jest.fn(),
      isValidTransition: jest.fn(),
      getStateWithTransitions: jest.fn()
    };

    // Update the mock implementation
    VulnerabilityStateService.mockImplementation(() => mockStateService);
  });

  afterAll(async () => {
    await sequelize.close();
  });

  beforeEach(async () => {
    await sequelize.truncate({ cascade: true });
    // Clear all mocks before each test
    jest.clearAllMocks();
  });

  const sampleVulnerability = {
    id: 1,
    title: 'SQL Injection',
    description: 'A potential SQL injection vulnerability',
    severity: 'High',
    affectedComponent: 'Login System',
    reporter: 'Mariano Lugones',
    state: 'Open'
  };

  describe('GET /vulnerabilities', () => {
    it('should return all vulnerabilities', async () => {
      vulnerabilityService.getAllVulnerabilities.mockResolvedValue([sampleVulnerability]);

      const response = await request(app)
        .get('/vulnerabilities')
        .expect('Content-Type', /json/)
        .expect(200);

      expect(response.body).toHaveLength(1);
      expect(response.body[0]).toEqual(sampleVulnerability);
    });

    it('should handle errors', async () => {
      vulnerabilityService.getAllVulnerabilities.mockRejectedValue(new Error('Database error'));

      await request(app)
        .get('/vulnerabilities')
        .expect(500)
        .expect({ message: 'Database error' });
    });
  });

  describe('GET /vulnerabilities/:id', () => {
    it('should return a vulnerability by id', async () => {
      vulnerabilityService.getVulnerabilityById.mockResolvedValue(sampleVulnerability);

      const response = await request(app)
        .get('/vulnerabilities/1')
        .expect('Content-Type', /json/)
        .expect(200);

      expect(response.body).toEqual(sampleVulnerability);
    });

    it('should return 404 for non-existent vulnerability', async () => {
      vulnerabilityService.getVulnerabilityById.mockRejectedValue(new Error('Vulnerability not found'));

      await request(app)
        .get('/vulnerabilities/999')
        .expect(404)
        .expect({ message: 'Vulnerability not found' });
    });
  });

  describe('POST /vulnerabilities', () => {
    it('should create a new vulnerability', async () => {
      const newVulnerability = { ...sampleVulnerability };
      delete newVulnerability.id;

      vulnerabilityService.createVulnerability.mockResolvedValue(sampleVulnerability);

      const response = await request(app)
        .post('/vulnerabilities')
        .send(newVulnerability)
        .expect('Content-Type', /json/)
        .expect(201);

      expect(response.body).toEqual(sampleVulnerability);
    });

    it('should handle validation errors', async () => {
      const invalidVulnerability = { title: 'Missing required fields' };

      vulnerabilityService.createVulnerability.mockRejectedValue(new Error('Validation error'));

      await request(app)
        .post('/vulnerabilities')
        .send(invalidVulnerability)
        .expect(400)
        .expect({ message: 'Validation error' });
    });
  });

  describe('PUT /vulnerabilities/:id/state', () => {
    it('should update vulnerability state', async () => {
      const updatedVulnerability = { 
        ...sampleVulnerability, 
        state: 'In Progress' 
      };

      vulnerabilityService.updateState.mockResolvedValue(updatedVulnerability);

      const response = await request(app)
        .put('/vulnerabilities/1/state')
        .send({ state: 'In Progress' })
        .expect('Content-Type', /json/)
        .expect(200);

      expect(response.body).toEqual(updatedVulnerability);
    });

    it('should reject invalid state transitions', async () => {
      vulnerabilityService.updateState.mockRejectedValue(
        new Error('Invalid state transition')
      );

      await request(app)
        .put('/vulnerabilities/1/state')
        .send({ state: 'InvalidState' })
        .expect(400)
        .expect({ message: 'Invalid state transition' });
    });
  });

  describe('DELETE /vulnerabilities/:id', () => {
    it('should delete a vulnerability', async () => {
      vulnerabilityService.deleteVulnerability.mockResolvedValue({ message: 'Deleted successfully' });

      await request(app)
        .delete('/vulnerabilities/1')
        .expect(200)
        .expect({ message: 'Deleted successfully' });
    });

    it('should return 404 for non-existent vulnerability', async () => {
      vulnerabilityService.deleteVulnerability.mockRejectedValue(new Error('Vulnerability not found'));

      await request(app)
        .delete('/vulnerabilities/999')
        .expect(404)
        .expect({ message: 'Vulnerability not found' });
    });
  });
}); 